name: Generate GRC Report with Lambda

on:
  repository_dispatch:
    types: [generate-report, sentrydigest-updated]
  schedule:
    - cron: '0 */3 * * *'  # Every 3 hours
  workflow_dispatch:
    inputs:
      feed_url:
        description: 'RSS Feed URL'
        required: false
        default: 'https://ricomanifesto.github.io/SentryDigest/feed.xml'
  workflow_run:
    workflows: ["Build and Deploy Lambda"]
    types:
      - completed

concurrency:
  group: grcinsight-report-${{ github.ref }}
  cancel-in-progress: true

env:
  AWS_REGION: us-east-1
  GO_FUNCTION_NAME: grcinsight-go-function
  PYTHON_FUNCTION_NAME: grcinsight-python-function

jobs:
  generate-report:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pages: write
      id-token: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Health check (Go Lambda)
      id: health
      run: |
        set -e
        PAYLOAD='{"httpMethod":"GET","path":"/health","headers":{}}'
        attempts=1
        max_attempts=5
        while [ $attempts -le $max_attempts ]; do
          echo "Health check attempt $attempts/$max_attempts"
          aws lambda invoke \
            --function-name "$GO_FUNCTION_NAME" \
            --payload "$PAYLOAD" \
            --cli-binary-format raw-in-base64-out \
            --region "$AWS_REGION" \
            health.json >/dev/null || true
          # Parse body which may be JSON string - more robust parsing
          BODY=$(cat health.json | jq -r '.body // empty')
          if [ -n "$BODY" ] && [ "$BODY" != "null" ]; then
            STATUS=$(echo "$BODY" | jq -r '.status // empty' 2>/dev/null || echo "unknown")
          else
            STATUS="unknown"
          fi
          echo "Reported status: ${STATUS:-unknown}"
          if [ "$STATUS" = "healthy" ]; then
            echo "Go Lambda health OK"
            break
          fi
          attempts=$((attempts+1))
          sleep 5
        done
        if [ "$STATUS" != "healthy" ]; then
          echo "Go Lambda health check failed" >&2
          exit 1
        fi

    - name: Set feed URL
      id: feed-url
      run: |
        FEED_URL=""
        if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
          FEED_URL="${{ github.event.client_payload.feed_url }}"
        elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          FEED_URL="${{ github.event.inputs.feed_url }}"
        fi
        if [ -z "$FEED_URL" ] || [ "$FEED_URL" = "null" ]; then
          FEED_URL="https://ricomanifesto.github.io/SentryDigest/feed.xml"
        fi
        echo "Using FEED_URL=$FEED_URL"
        echo "FEED_URL=$FEED_URL" >> $GITHUB_OUTPUT

    - name: Invoke Lambda report generation
      id: lambda-invoke
      run: |
        # Create payload for Lambda invocation
        PAYLOAD=$(cat <<EOF
        {
          "httpMethod": "POST",
          "path": "/api/v1/reports/generate",
          "headers": {
            "Content-Type": "application/json"
          },
          "body": "{\"feed_url\": \"${{ steps.feed-url.outputs.FEED_URL }}\", \"config\": {\"model\": \"gpt-4\", \"max_tokens\": 4000, \"focus_areas\": [\"governance\", \"compliance\", \"risk\"]}}"
        }
        EOF
        )

        echo "Invoking Lambda function: $GO_FUNCTION_NAME"

        # Invoke Go Lambda function
        aws lambda invoke \
          --function-name $GO_FUNCTION_NAME \
          --payload "$PAYLOAD" \
          --cli-binary-format raw-in-base64-out \
          --region $AWS_REGION \
          lambda-response.json

        # Check if invocation was successful
        if [ $? -eq 0 ]; then
          echo "Lambda invocation successful"
          cat lambda-response.json

          # Extract report ID from response
          REPORT_ID=$(cat lambda-response.json | jq -r '.body' | jq -r '.report_id // empty')
          if [ ! -z "$REPORT_ID" ]; then
            echo "REPORT_ID=$REPORT_ID" >> $GITHUB_OUTPUT
            echo "Report generated with ID: $REPORT_ID"
          else
            echo "Failed to extract report ID from response"
            exit 1
          fi
        else
          echo "Lambda invocation failed"
          exit 1
        fi

    - name: Retrieve generated report
      id: get-report
      if: steps.lambda-invoke.outputs.REPORT_ID
      run: |
        set -e
        echo "Retrieving report ID: ${{ steps.lambda-invoke.outputs.REPORT_ID }}"

        REPORT_ID=${{ steps.lambda-invoke.outputs.REPORT_ID }}
        MAX_ATTEMPTS=${MAX_ATTEMPTS:-90}   # up to ~15 minutes
        SLEEP_SECONDS=${SLEEP_SECONDS:-10}

        attempt=1
        while [ $attempt -le $MAX_ATTEMPTS ]; do
          echo "Attempt $attempt/$MAX_ATTEMPTS to fetch report..."

          GET_PAYLOAD='{"httpMethod":"GET","path":"/api/v1/reports/'$REPORT_ID'","headers":{}}'

          aws lambda invoke \
            --function-name "$GO_FUNCTION_NAME" \
            --payload "$GET_PAYLOAD" \
            --cli-binary-format raw-in-base64-out \
            --region "$AWS_REGION" \
            report-response.json >/dev/null

          # Parse body; handle both raw object or JSON string body
          cat report-response.json | jq -r '.body | (try fromjson catch .)' > report-data.json

          STATUS=$(jq -r '.status // empty' report-data.json)
          TITLE=$(jq -r '.title // empty' report-data.json)
          CONTENT=$(jq -r '.content // empty' report-data.json)
          GENERATED_AT=$(jq -r '.generated_at // empty' report-data.json)

          if [ "$STATUS" = "failed" ]; then
            echo "Report status is 'failed'. Aborting early." >&2
            echo "Response:" >&2
            cat report-data.json >&2 || true
            exit 1
          fi

          if [ "$STATUS" = "completed" ]; then
            echo "Report completed. Building site files..."

            # Create/refresh site directory and Markdown report only.
            # We keep the committed static index.html + assets (site/static/*)
            # and let the UI load this Markdown.
            mkdir -p site
            SAFE_TITLE=${TITLE:-GRC Intelligence Report}
            SAFE_GENERATED=${GENERATED_AT}
            SAFE_CONTENT=${CONTENT}
            CONTENT_LEN=$(printf %s "$CONTENT" | wc -c | tr -d ' ')
            echo "Content length (bytes): ${CONTENT_LEN:-0}"
            if [ -z "$SAFE_CONTENT" ] || [ "$SAFE_CONTENT" = "null" ]; then
              SAFE_CONTENT="# No content\n\nThe report generation completed, but no content was returned by the backend."
            fi
            echo "# ${SAFE_TITLE}" > site/index.md
            echo "**Generated:** ${SAFE_GENERATED}" >> site/index.md
            echo "${SAFE_CONTENT}" >> site/index.md

            # If content is empty, append a minimal articles outline to aid readability
            if [ -z "$CONTENT" ] || [ "$CONTENT" = "null" ]; then
              echo "Attempting to fetch articles to build a minimal outline..."
              GET_ARTS_PAYLOAD='{"httpMethod":"GET","path":"/api/v1/reports/'$REPORT_ID'/articles","headers":{}}'
              aws lambda invoke \
                --function-name "$GO_FUNCTION_NAME" \
                --payload "$GET_ARTS_PAYLOAD" \
                --cli-binary-format raw-in-base64-out \
                --region "$AWS_REGION" \
                articles-response.json >/dev/null || true
              cat articles-response.json | jq -r '.body | (try fromjson catch .)' > articles-data.json || true
              ART_COUNT=$(jq -r '.total // 0' articles-data.json 2>/dev/null || echo 0)
              if [ "${ART_COUNT:-0}" -gt 0 ]; then
                echo "" >> site/index.md
                echo "## Articles Outline" >> site/index.md
                echo "_Auto-rendered placeholder until full content is available._" >> site/index.md
                jq -r '.articles[] | "- [\(.title // "Untitled")] (\(.url // "#"))"' articles-data.json | head -n 50 >> site/index.md || true
              else
                echo "No articles returned; skipping outline."
              fi
            fi

            echo "Report files created successfully"
            break
          else
            echo "Status: ${STATUS:-unknown}. Waiting ${SLEEP_SECONDS}s..."
            sleep $SLEEP_SECONDS
            attempt=$((attempt+1))
          fi
        done

        if [ $attempt -gt $MAX_ATTEMPTS ]; then
          echo "Timed out waiting for report to complete" >&2
          exit 1
        fi

    - name: Dump recent Lambda logs (Go & Python)
      if: failure()
      continue-on-error: true
      env:
        SINCE_MINUTES: 60
      run: |
        set -e
        echo "Collecting CloudWatch logs for the last ${SINCE_MINUTES} minutes..."
        END_TS=$(date +%s000)
        START_TS=$(( ( $(date +%s) - SINCE_MINUTES*60 ) * 1000 ))
        for FN in "$GO_FUNCTION_NAME" "$PYTHON_FUNCTION_NAME"; do
          echo "=== Logs for ${FN} ==="
          LG="/aws/lambda/${FN}"
          if aws logs describe-log-groups --log-group-name-prefix "$LG" >/dev/null 2>&1; then
            aws logs filter-log-events \
              --log-group-name "$LG" \
              --start-time "$START_TS" \
              --end-time "$END_TS" \
              --max-items 400 \
              --output json > cw.json || true
            jq -r '.events[] | "[\(.timestamp)] \(.message)"' cw.json | sed -e 's/\\n/\n/g' | sed -e 's/\r$//' | tee cw.txt || true
            echo "--- ERROR lines (last 50) ---"
            grep -i "error" cw.txt | tail -n 50 || true
            echo "--- Last RequestId ---"
            grep -E "(RequestId:|START RequestId:)" cw.txt | tail -n 1 || true
          else
            echo "No log group found: $LG" >&2
          fi
          echo
        done

    - name: Commit and push report
      if: steps.get-report.conclusion == 'success'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add site/index.md
        git commit -m "Update GRC intelligence report [automated] [skip ci]" || exit 0
        git push

    - name: Upload Pages artifact
      if: steps.get-report.conclusion == 'success'
      uses: actions/upload-pages-artifact@v3
      with:
        path: site

    - name: Deploy to GitHub Pages
      if: steps.get-report.conclusion == 'success'
      id: deployment
      uses: actions/deploy-pages@v4
